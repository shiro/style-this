name: Release Notification

on:
  push:
    paths:
      - 'packages/*/CHANGELOG.md'

permissions:
  contents: write

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch at least 2 commits for git diff to work

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Setup Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@main

      - name: Detect Changed Packages
        id: detect_changes
        run: |
          # Get changed CHANGELOG.md files from the last commit
          changed_files=$(git diff --name-only HEAD~1 HEAD | grep '^packages/.*/CHANGELOG\.md$' || true)

          # If no changes detected, fall back to all CHANGELOG.md files (e.g., first commit)
          # if [ -z "$changed_files" ]; then
          #   changed_files=$(find packages -name "CHANGELOG.md" -type f)
          # fi

          # Extract package names and create comma-separated list
          changed_packages=$(echo "$changed_files" | sed 's|^packages/||; s|/CHANGELOG\.md$||' | sort -u | tr '\n' ',' | sed 's/,$//')

          echo "Changed packages: $changed_packages"
          echo "packages=$changed_packages" >> $GITHUB_OUTPUT

      - name: Install dependencies
        if: steps.detect_changes.outputs.packages != ''
        run: nix-shell --run "pnpm install"

      - name: Build project
        if: steps.detect_changes.outputs.packages != ''
        run: nix-shell --run "pnpm build"

      - name: Process each changed package
        if: steps.detect_changes.outputs.packages != ''
        run: |
          IFS=',' read -ra PACKAGES <<< "${{ steps.detect_changes.outputs.packages }}"

          for package in "${PACKAGES[@]}"; do
            echo "Processing package: $package"

            changelog_file="packages/$package/CHANGELOG.md"

            if [ ! -f "$changelog_file" ]; then
              echo "CHANGELOG.md not found for package $package, skipping"
              continue
            fi

            # Parse the changelog to get the latest version
            latest_version=$(grep -m 1 "^## " "$changelog_file" | sed 's/^## //')

            if [ -z "$latest_version" ]; then
              echo "No version found in CHANGELOG.md for package $package, skipping"
              continue
            fi

            echo "Latest Version for $package: $latest_version"

            # Extract description for the latest version
            description=$(awk '/^## / {if(found) exit; found=1; next} found && /^## / {exit} found {print}' "$changelog_file" | sed '/^$/d')

            # Extract version number for tag (e.g., "0.1.0" from "0.1.0 (2025-12-03)")
            version_tag=$(echo "$latest_version" | grep -oE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?')

            if [ -z "$version_tag" ]; then
              echo "Could not extract version tag from: $latest_version for package $package, skipping"
              continue
            fi

            echo "Version tag for $package: $version_tag"

            # Create tag name with package prefix
            tag_name="${package}-v${version_tag}"
            release_name="${package} ${latest_version}"

            # Check if release already exists using GitHub API
            if gh release view "$tag_name" >/dev/null 2>&1; then
              echo "Release $tag_name already exists, skipping"
              continue
            fi

            echo "Creating release for $package..."

            # Create archive from package directory
            cd "packages/$package"
            archive_name="${package}-${version_tag}.tar.gz"

            # Create archive of package contents
            tar -czf "../../$archive_name" --exclude='node_modules' --exclude='.git' $(git ls-files)

            cd ../..

            echo "Created archive: $archive_name"

            # Create GitHub Release
            gh release create "$tag_name" \
              --title "$release_name" \
              --notes "$description" \
              "./$archive_name"

            echo "Created release $tag_name with asset $archive_name"

            # Clean up archive
            rm -f "./$archive_name"
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

